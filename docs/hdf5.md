# HDF5

## Features

HDF5 is a very convenient file format for storing scientific data.  It combines
the convenience of text files with the performance of binary files.

An HDF5 can be viewed as a file system.  The file can have groups (directories)
that can contain multiple data sets (files), hence the name, Hierarchical Data
Format.  The file, its groups and data sets can be annotated with
meta-information, e.g., the units of the data.

Besides the raw data, datasets provide also meta-information:

* the name of the data set,
* the data type of the values,
* the dataspace, i.e., the rank and dimensions of the dataset.

Datasets can have many different types, but broadly, they belong to two
categories: atomic and compound.

Some examples of atomic data types are floating point and integer numbers, time,
strings, bitfields and opaque.  The latter can be used to store binary objects
such as JPEG or TIFF images.

Compound data types are arrays, variable length (1 dimensional array of some
data types), compound (similar to user defined types) and enumerations.

One of the major advantages of HDF5 is that bindings are available for
most programming languages that are relevant in scientific computing.  A
file generated by an application developed in a programming language can
be read by an application in a completely different program language.  Even
better, HDF5 is platform independent.

HDF5 s a very nice data format for HPC applications since it supports
parallel I/O on file systems such as Lustre or IBM Spectrum Scale.  This allows
multiple threads or processes of an application to perform I/O operations in
parallel.

HDF5 has excellent support for partial reads or writes of datasets through
hyperslabs.  You can view a hyperslab as subarrays in Fortran, or slices in
other programming languages.  Unfortunately, using hyperslabs requires
a considerable number of lines of code, and is out of scope for this course.


## Workflow

Using HDF5 requires considerable effort.  Here, you will get an overview of
writing data to an HDF5 file, examples of reading data are provided as well.

### Initialization

The first step is to initialize the HDF5 Fortran interface.  This should be
before any other HDF5 related operation.

~~~~fortran
integer :: error
...
call h5open_f(error)
~~~~

### Opening a file

The next step is to open a file for reading, writing or appending.  For
instance, the following code snippet opens a file for writing, replacing an
existing file if that exists.

~~~~fortran
integer(kind=hid_t) :: file_id
character(len=1024) :: file_name
...
call h5fcreate_f(file_name, H5F_ACC_TRUNC_F, file_id, error)
~~~~

The argument `file_id` has intent out, and it will contain the file identifier
subsequently used for further file operations.  Note that HDF5 defines its own
kinds for identifiers `hid_t`.  Make sure to use these kinds to avoid very
unpleasant surprises. `H5F_ACC_TRUNC_F` ensures that
when a file with the given name exists, it is truncated, i.e., replaced.
Several other options are available and can be found in the documentation.

Note the `f`-prefix in the procedure name: all file-related procedures share
this prefix.  It is part of a consistent naming convention.

### Creating a group

Once the file has been opened for writing or modification, groups can be
created.

~~~~fortran
integer(kind=hid_t) :: group_id
character(len=1024) :: group_name
...
call h5gcreate_f(file_id, group_name, group_id, error)
~~~~

Again, interaction with the new group will be through its identifier,
`group_id`.  Note the `g`-prefix.


### Creating a dataspace

Before a dataset can be created, you first need to create the dataspace.
The rank and the dimensions of the dataset have to be defined.

~~~~fortran
integer(kind=hid_t) :: pos_dspace_id
integer, parameter :: pos_rank = 2, pos_space_rank = 3
integer, parameter :: nr_particles = 10
integer(hsize_t), dimension(pos_rank) :: pos_dim = [ pos_space_rank, &
                                                     nr_particles ]
...
call h5screate_simple_f(pos_rank, pos_dim, pos_dspace_id, error)
~~~~

This creates a dataspace for rank 2 and dimensions $$3 \times 10$$.
Note the `s`-prefix for the dataspace-related procedures, and the use
of the `hsize_t` kind for specifying dimensions.


### Creating a dataset

A dataset can now be created, this requires a name, a dataspace and a type.

~~~~fortran
integer(kind=hid_t) :: pos_dset_id
character(len=1024) :: pos_dset_name
...
call h5dcreate_f(group_id, pos_dset_name, H5T_NATIVE_REAL, &
                 pos_dspace_id, pos_dset_id, error)
~~~~

The `group_id` is used as the location for the dataset, so the dataset will
be in this group.  The type is atomic, `H5T_NATIVE_REAL`, so single precision
in the format native to the platform the application runs on.  Note the`d`-prefix.


### Writing data

Finally, data can be writing to the dataset you just created.

~~~~~fortran
real(kind=sp), dimension(pos_space_rank, nr_particles) :: pos
...
call h5dwrite_f(pos_dset_id, H5T_NATIVE_REAL, pos, pos_dim, error)
~~~~

An entire two-dimensional array is writting by a single procedure call.


### Closing up

Once all operations have been perofrmed on and HDF5 entity, it should be
closed.  This is the case for datasets, dataspaces, groups and files.

~~~~fortran
call h5dclose_f(pos_dset_id, error)
call h5sclose_f(pos_dspace_id, error)
call h5gclose_f(group_id, error)
call h5fclose_f(file_id, error)
~~~~

When all HDF5 operations are completed, the Fortran HDF5 interface is
closed as well.

~~~~fortran
call h5close_f(error)
~~~~

## Wrap up

As you've seen, working with HDF5 files in Fortran is quite labor intensive
and finicky.  However, given the advantages of the data format, it is well owrth
the investment.

This only scratched the surface of HDF5 features.  If you are interested to
learn more about HDF5, the PRACE courses on the subject are recommended.
